# Codex会話履歴ビューア 要件

## 概要
- `/Users/osabekenta/.codex/sessions/YYYY/MM/DD/*.jsonl` に保存されたCodexの会話履歴（JSONL形式）を読み取り、一覧・閲覧できるフルスタックアプリケーションを構築する。
- ユーザーは日付単位でセッションを閲覧し、個々の会話の詳細と発言者（ユーザーまたはCodex）、内容を確認できる。
- 想定利用環境は単一ユーザーによるデスクトップ利用であり、多人数同時利用やリモートアクセスは対象外とする。

## 目標
- カレンダー日付ごとに整理されたCodex会話の一覧を、検索しやすく明瞭に提示する。
- 会話概要とメッセージ詳細の間を高速に遷移できるUXを提供する。
- Bootstrapのレスポンシブコンポーネントを活用し、主要デスクトップブラウザで一貫した体験を実現する。
- Dockerベースで再現性の高い開発・デプロイワークフローを提供する。

## 非目標
- 新しい会話ログのリアルタイム取得・記録（既存ログの閲覧が目的）。
- 元ファイル内の履歴メッセージの編集・削除・マスキング。
- ユーザー認証・認可や複数ユーザーでの共同利用。
- クラウド環境へのデプロイ作業（ローカルのコンテナ運用に集中）。

## 想定ユーザーとユースケース
- **主たるユーザー:** Codexログを保持するローカル開発者。過去のやり取りを検索・フィルタ・再確認したい。
- **代表的なシナリオ:**
  - 日付範囲を絞って特定の会話を探し出す。
  - セッション全体のトランスクリプトを参照し、得られた知見やコマンドをコピーする。
  - 多数のトランスクリプトを横断してキーワード検索を行う（例: “docker-compose”）。
  - 必要なメッセージ断片を手動でコピー・エクスポートする（閲覧専用）。

## データソースと前提
- ファイル構成: `/Users/osabekenta/.codex/sessions/YYYY/MM/DD/<session-id>.jsonl`。1行が1件のイベントを表すJSONオブジェクト。
- JSON共通フィールド:  
  - `timestamp`（ISO-8601, UTC）  
  - `type` — 代表例は `session_meta` / `response_item` / `turn_context` / `event_msg`  
  - `payload` — `type`ごとに構造が異なる
- `response_item` のうち `payload.type === "message"` は会話本文を構成し、`payload.role` が `user` / `assistant` / `tool` 等の発言者、`payload.content` は複数セグメント（`type: "input_text" | "output_text" | ...`）で構成される。
- `response_item` の `payload.type === "reasoning"` は暗号化済みコンテンツを含むためUIには表示せず、安全に無視または保持するポリシーを決める。
- `event_msg`（例: `user_message`, `token_count`）や `function_call` 系のログはメタ情報として扱い、必要に応じて詳細タブやツール実行履歴として表示する。
- バックエンドは上記の生データを正規化し、フロントエンドに対して `NormalizedMessage { timestamp, role, segments[], source_type }` のような統一フォーマットで提供する。
- ディレクトリ構成やファイル名は環境変数で設定可能とし、パスの直書きを避ける。
- ファイルシステムアクセスはブラウザ単体では扱えないため、バックエンド（サーバーサイド）がファイルI/Oと正規化処理を担う。
- ファイル読み込みは大規模履歴（数万メッセージ）や一部破損ファイルに対しても安全に処理し、失敗行はログに残しつつスキップする。

## 機能要件

### セッション探索とインデックス化
1. バックエンド起動時にディレクトリを再帰的に走査し（手動リフレッシュAPIからも実行可能）、メモリまたは永続化されたセッションインデックスを構築する。
2. セッション単位で以下のメタデータを保持する: セッションID（ファイル名）、絶対パス、日付（ディレクトリ構造または最初のタイムスタンプから算出）、メッセージ数、最終更新日時。
3. バックエンドを再起動せずにオンデマンド再インデックスができ、更新中も読み取りリクエストをブロックしない。
4. 新規・更新ファイルを検知できる差分更新手法（例: mtime比較）を備える。

### セッション一覧UI
1. 既定表示はカレンダー日付（降順）でグルーピングしたページネーションまたは仮想スクロールリスト。
2. 各セッションカード/行には、セッションID（読みやすいラベル）、メッセージ数、最初/最後のメッセージ時刻、最初のユーザープロンプトの抜粋を表示する。
3. フィルタリング機能:
   - 日付範囲（開始日・終了日）。
   - 発言者（ユーザーのみ／Codexのみを含むセッション）。
   - メッセージ本文のキーワード検索（バックエンドで処理）。
4. 並び替え: 最新活動順、メッセージ数順、セッションID順。
5. フィルタ結果が0件の場合は適切な空状態メッセージを表示する。

### 会話詳細ビュー
1. セッション選択時にページ遷移を伴わず（React Routerでルーティング）全メッセージを読み込む。
2. メッセージタイムラインに以下を表示:
   - 正規化済みロール（`user` / `assistant` / `tool` など）に応じた発言者ラベルと視覚的な差別化（色・アイコン）。
   - タイムスタンプはローカルタイムゾーン表示に加え相対時刻の補助表示。
   - メッセージ本文は空白を保持しつつマークダウン的表現（簡易コードブロック・インラインコード）に対応し、HTMLはサニタイズする。
   - reasoningログや暗号化済みコンテンツは既定で非表示とし、必要に応じて詳細トグルで確認できるようにする。
3. セッション一覧への戻り操作とURLパラメータによるディープリンクをサポート。
4. 各メッセージにコピー機能を提供する。
5. （任意）長文のCodexレスポンスを折りたたむ「もっと見る」トグルを実装する。

### 検索とフィルタリング
1. バックエンドはメッセージ本文に対する全文検索API（大文字小文字無視・部分一致・ページネーション対応）を提供する。
2. フロントエンドは検索入力をデバウンスし、結果をセッション一覧にインライン表示する。
3. 会話詳細ビューではキーワードのハイライト表示を行う。
4. フィルタを一括解除する操作（“フィルタをクリア”）を提供する。

### エラーハンドリングと堅牢性
1. バックエンドはファイルI/OやJSONパースエラーを捕捉し、ログに記録しつつ正常なセッションは継続提供する。
2. フロントエンドはAPI失敗時にリトライ可能なユーザーフレンドリーなアラートを表示する。
3. 存在しないセッションへのアクセスには404、予期しないエラーには500を返す。
4. APIレート制限や長時間処理がUIをブロックしないよう、バックグラウンドジョブやストリーミング処理を検討する。

## API要件（Ruby on Rails）
- バージョン: プロジェクト開始時点の最新安定版Rails。
- エンドポイントは `/api` 配下に配置する。
- 提供予定のエンドポイント:
  - `GET /api/sessions`: ページネーション付きセッション一覧。クエリパラメータ（`page`, `per_page`, `start_date`, `end_date`, `speaker`, `q`, `sort`）に対応。
  - `POST /api/sessions/refresh`: バックグラウンドで再インデックスを開始し、即座に受理レスポンスとジョブIDを返す。
  - `GET /api/sessions/:id`: セッションメタデータと、`{ timestamp, role, segments[], source_type, raw }` など正規化済みメッセージ配列を返す。
  - `GET /api/search`: セッション参照・抜粋・ハイライト情報を含むメッセージ検索結果を返す（検索ヒット箇所はセグメント単位でマークする）。
- レスポンス形式: `data`, `meta`, `errors` を含む一貫したJSONエンベロープ。
- バックグラウンド処理: デフォルトはActive Job + Asyncアダプタ。必要に応じてSidekiq等へ切り替え可能とする。
- 設定:
  - 環境変数 `CODEX_SESSIONS_ROOT`（デフォルト `/Users/osabekenta/.codex/sessions`）。
  - 検索インデックスの並列度やキャッシュTTLを設定可能にする。

## バックエンド処理とデータ層
- 初期実装では永続DBを必須とせず、メモリまたは軽量ストア（例: SQLite）にファイルシステムからキャッシュしたインデックスを格納する。
- JSONL読み込みのための抽象化レイヤーを用意し、将来的なDB永続化に備える。
- 以下を担うサービスオブジェクトを実装する:
  - ディレクトリ走査とマニフェスト生成。
  - スキーマ検証を伴うメッセージパース。
  - 会話エントリの正規化（NormalizedMessage生成、セグメント分解、reasoning・functionログの区別）。
  - 全文検索（将来的にPostgreSQL + `pg_search` 等へ拡張可能な設計）。
- インデックス処理に関する構造化ログ（JSON）を出力する。
- 大容量ファイル対応のため、ファイル全体をメモリに読み込まないストリーミング処理を検討する。

## フロントエンド要件（React + TypeScript）
- ビルドツールは最新のViteを使用し、HMRを有効化する。
- React Router（最新）を利用し、以下のルート構成を想定:
  - `/` → セッション一覧ビュー
  - `/sessions/:id` → 会話詳細ビュー
  - `/search`（任意）→ 全文検索結果ビュー
- グローバル状態・データ取得は最新のReact Query（TanStack Query）またはFetchラッパーでキャッシュと同期を管理する。
- UIコンポーネントはBootstrapをベースにスタイリングし、必要に応じて `clsx` 等のユーティリティを利用する。
- アクセシビリティ: WCAG AA準拠を目指し、キーボード操作・aria属性・フォーカス管理を実装する。
- データ取得時にはローディングスケルトンやスピナーを表示する。
- 幅768px以上のデスクトップ／タブレット表示でのレスポンシブ対応を保証する。

## テスト戦略
- **バックエンド:** RSpecでサービスオブジェクト、リクエスト、ジョブのテストを実施。JSONLサンプルデータのフィクスチャを用意し、インデックス／検索ロジックのカバレッジ80%以上を目標とする。
- **フロントエンド:** Vitest + React Testing Libraryでコンポーネント・ユニットテストを行い、セッション一覧・詳細・検索フィルタ等の主要コンポーネントを網羅。メッセージ表示のスナップショットテストも検討。
- **E2E:** Playwrightでセッション閲覧、検索フロー、バックエンド不調時などのシナリオを自動化。
- **CI:** `pnpm lint`、フロントエンド単体テスト、RSpec、Playwright（ヘッドレス）を実行。GitHub Actionsワークフローの雛形を提供（任意）。

## 開発者体験とツール
- フロントエンド依存のパッケージ管理は最新のpnpm。
- Node.jsは22系の最新安定版とし、`.nvmrc` や `.tool-versions` などで管理。
- Rubyは最新安定版を採用し、Bundlerを標準利用。
- 代表的なコマンドをまとめたMakefileやタスクランナー（`make setup`, `make test` 等）を提供する。
- フォーマッタとしてフロントエンドにPrettier、バックエンドにRuboCopを導入する。

## インフラとデプロイ
- Dockerで開発環境と実行環境を統一する:
  - サービス構成例: `frontend`, `backend`, （任意で）バックグラウンドジョブ用 `worker`, 必要に応じてリバースプロキシ `proxy`（nginx等）。
  - `/Users/osabekenta/.codex/sessions` をボリュームとしてマウントし、バックエンドがログを読み取れるようにする。
- docker-composeで複数サービスを起動し、開発時はバインドマウントでホットリロードを有効にする。
- 環境変数は `.env.example` を用意して共有する。
- `docker compose up` でフロントエンド（Vite開発サーバー）とバックエンド（Railsサーバー）が同一ネットワーク上で起動する手順をドキュメント化する。
- 本番想定ではマルチステージビルドで最適化したDockerfile（アセット事前ビルド、不要なモジュール削減）を検討する。

## セキュリティとプライバシー
- ユーザーの明示的な許可なしに外部ネットワークへアクセスしない（オフラインファースト）。
- ログ由来のXSSを防ぐため、メッセージ表示時にサニタイズを実施する。
- ファイルシステムの権限を尊重し、元ログファイルを変更・削除しない。
- いつ・どのディレクトリを走査したか等のインデックス操作を監査ログとして記録する。

## パフォーマンス要件
- セッション一覧初回ロードは最大1,000件で2秒以内を目標とする。
- APIレスポンスはページネーションで全データ送信を避ける。
- 長いメッセージリストには遅延読み込みや仮想化を適用する。
- 検索インデックスはキャッシュし、TTL設定とリフレッシュ時の無効化を行う。

## ドキュメンテーション
- `README.md` にセットアップ手順、環境変数、Docker利用方法、テストコマンドを記載する。
- バックエンド／フロントエンドのアーキテクチャドキュメント（例: ADR）を必要に応じて追加する。
- `fixtures/` にテスト・デモ用のサンプルデータを同梱する。

## 未確定事項・確認事項
- 暗号化されたreasoningログやfunction_call出力をUIでどの程度露出させるか（完全非表示 / 詳細タブ / エクスポートのみ等）。
- セッションIDをファイル名のまま扱うか、初回プロンプト等から人間向けに変換するか。
- 予想データ量に応じた検索インデックス方式（完全メモリ、外部DB利用など）の選定。
- v1でのエクスポート／共有機能（例: トランスクリプトのダウンロード）の必要性。
- 自動リフレッシュ頻度の要否（Cron的な定期実行か、手動トリガーのみにするか）。
- ダークモードなど追加テーマの要件有無。
